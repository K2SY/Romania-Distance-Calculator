# -*- coding: utf-8 -*-
"""HW2Foster.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L2OV36YbpsRUPJPjlztMiCpzjQjwqse5
"""

from ast import main
import heapq

# Road map of Romania
# Data structure that list cities and each neighboring city connecting to it with is respective distance
# Step one: map the diffrent cities of romania with each city being a key and the neighboring cities and distance be the value
def load_map():
  return{
      #city: { connecting city: Distance }
      'Arad': {'Zerind': 75, 'Sibiu': 140, 'Timisoara': 118},
      'Zerind': {'Arad': 75, 'Oradea': 71},
      'Oradea': {'Zerind': 71, 'Sibiu': 151},
      'Timisoara': {'Lugoj': 111, 'Arad': 118},
      'Lugoj': {'Timisoara': 111, 'Mehadia': 70},
      'Mehadia': {'Lugoj': 70, 'Drobeta': 75},
      'Drobeta': {'Mehadia': 75, 'Craiova': 120},
      'Craiova': {'Rimnicu Vilcea': 146, 'Pitesti': 138, 'Drobeta': 120},
      'Rimnicu Vilcea': {'Sibiu': 80, 'Craiova': 146, 'Pitesti': 97},
      'Sibiu': {'Arad': 140, 'Oradea': 151, 'Rimnicu Vilcea': 80, 'Fagaras': 99},
      'Fagaras': {'Sibiu': 99, 'Bucharest': 211},
      'Pitesti': {'Rimnicu Vilcea': 97, 'Craiova': 138, 'Bucharest': 101},
      'Bucharest': {'Fagaras': 211, 'Pitesti': 101, 'Giurgiu': 90, 'Urziceni': 85},
      'Giurgiu': {'Bucharest': 90},
      'Urziceni': {'Bucharest': 85, 'Hirsova': 98, 'Vaslui': 142},
      'Hirsova': {'Urziceni': 98, 'Eforie': 86},
      'Eforie': {'Hirsova': 86},
      'Vaslui': {'Urziceni': 142, 'Iasi': 92},
      'Iasi': {'Vaslui': 92, 'Neamt': 87},
      'Neamt': {'Iasi': 87}
  }

# Step two: Implemente the Uniform Cost Search algorith to find the lowest cost path to naviagte between two cities
def cost_search(romania_map, origin_city, destination_city):
  queue = []
  heapq.heappush(queue, (0, origin_city, []))
  visted_cities = set()
  count = 0

  print("start:[{origin_city}, 0]")


  while queue:

    # Step 3: Identifies and extracts the path with the lowest cost
    cost, current_city, path_taken = heapq.heappop(queue)
    # if destination is reached prints the solution and return
    if current_city == destination_city:
      print("\nSolution")
      print(f"Final Iteration: {'->'.join(path_taken + [destination_city])}")
      print(f"Cost: {origin_city} to {destination_city} is {cost}")
      return
    # Skips over cities already visited
    if current_city in visted_cities:
      continue
    visted_cities.add(current_city)

    next_state = []
    # adds neighboring cities explored and adds them to the queue if not already in visited cities set
    for next_closest_city, travel_cost in romania_map[current_city].items():
      if next_closest_city not in visted_cities:
        new_path = path_taken + [current_city]
        next_cost = cost + travel_cost
        heapq.heappush(queue, (next_cost, next_closest_city, new_path))
        next_state.append(f"[{'->'.join(new_path + [next_closest_city])}, {next_cost}]")

    count = count + 1
    if next_state:
      print(f"Iteration{count}: {{{','.join(next_state)}}}")
    else:
      print(f"Iteration3{count}: no new paths added, {cost}")

  print("No path found")

#Main function for testing use ability
def main():

  #input is case sensitve Captial letter for first letter of city
  map = load_map()
  origin_city = input("Enter origin city:")
  destination_city = input("Enter the destination city:")

  if origin_city not in map or destination_city not in map:
    print("Invalid city: Please try again with a valid city")
    return

  cost_search(map, origin_city, destination_city)



if __name__ == "__main__":
  main()

